# The Algorithm

To compute the Fibonacci sequence in parallel, we need to find a way to split the work into smaller 
units that can operate independently. Since the definition of the function that describes the sequence
is highly dependent on the previous computed values to obtain the next term, a change in the approach 
to this problem is needed.

The Fibonacci sequence can be described by the function $fib(n)$

$$
fib(n) = \begin{cases}
  0 & n = 0 \\
  1 & n = 1 \\
  fib(n-1)+fib(n-2) & n \geq 2
\end{cases}
$$

Here are some values of the sequence:

| $n$ | $fib(n)$ |
|---|:------:|
| 0 | 0 |
| 1 | 1 |
| 2 | 1 | 
| 3 | 2 | 
| 4 | 3 |
| 5 | 5 |
| 6 | 8 |

## The growth of the sequence

Given a function $F(x)$ with a structure similar to $fib(n)$ based on two constants $u$ and ${u_{0}}$, defined as

$$ 
F(x) = \begin{cases} 
  {u_{0}} & x = 0 \\
  u  & x = 1 \\
  F(x-1)+F(x-2) & x \geq 2
\end{cases}
$$

The sequence generated is

| $x$ | $F(x)$ |
|-|:--:|
|0| ${u_{0}}$       |
|1| $u$             |
|2| $u  + {u_{0}}$  |
|3| $2u + {u_{0}}$  |
|4| $3u + 2{u_{0}}$ |
|5| $5u + 3{u_{0}}$ |
|6| $8u + 5{u_{0}}$ |

If ${u_{0}}=0$, the generated sequence is identical to the Fibonacci sequence. When $u = 0$, we can examine the
behavior of the second term of $F$:

| $x$ | $F(x) \text{ with } u=0$|
|-|:--:|
|0| ${u_{0}}$      |
|1| 0             |
|2| $0 + {u_{0}}$  |
|3| $0 + {u_{0}}$  |
|4| $0 + 2{u_{0}}$ |
|5| $0 + 3{u_{0}}$ |
|6| $0 + 5{u_{0}}$ |
|7| $0 + 8{u_{0}}$ |
|8| $0 + 13{u_{0}}$ |

From $x \geq 2$ and $u = 0$, the values generated by $F$ follow the pattern $F(x) = fib(x-1){u_{0}}$.
Knowing how the terms $F$ grow permits us to rewrite its definition. The revised definition of $F(x)$ 
is as follows:

$$
  F(x) = \begin{cases}
    {u_{0}} & x = 0 \\
    u & x = 1 \\
    fib(x)\cdot {u} + fib(x-1)\cdot {u_{0}} & x \geq 2
  \end{cases}
$$

## Creating a parallel sequence
It is possible to define a function that grows in parallel with another Fibonacci-like sequence by
defining the initial terms properly. Using $F$ defined in the previous examples, let's define a parallel
function $K$ dependent on $F$ and a constant $m \geq 1$.

$$
  K(t) = \begin{cases}
    F(m-1) & t = 0 \\
    F(m)   & t = 1 \\
    K(t-1) + K(t-2) & t \geq 2
  \end{cases} 
$$

In this case $m$ needs to be greater than or equal to 1, because $F(m-1)$ is undefined when $m=0$.

Some properties can be observed in the structure of $K$. Since $K(0)$ and $K(1)$ are adjacent terms from the
sequence $F$, every value $K(t)$ with $t \geq 2$ is a continuation of the values of $F$ starting from $F(m)$. 
This can be seen more clearly by examining $K(2)$.

$$
  \begin{align*}
    K(2) &= K(1) + K(0) \\
    & = F(m) + F(m-1) \\
    & = F(m+1) \\
    & \Rightarrow K(n) = F(m+n-1) & (I)
  \end{align*}
$$

Furthermore, $K$ generates a Fibonacci-like sequence, so it can be defined as

$$
  K(t) = \begin{cases}
    F(m-1) & t = 0 \\
    F(m)   & t = 1 \\
    fib(t)\cdot F(m) + fib(t-1)\cdot F(m-1) & t \geq 2
  \end{cases} 
$$

This new definition of $K$ is the key to solving the dependencies between the computations of parts 
of the Fibonacci sequence. Knowing the values of $fib(m)$ and $fib(m-1)$ allows us to compute the 
value of $fib(2m)$ and $fib(2m-1)$. This is relies on the idea that we can always generate a parallel
sequence starting at any point in the main computation.

## Computing Fibonacci based on intervals
Given $m = 10$ and $u=1$, making $F(x) = fib(x)$, knowing $F(10)$ and $F(9)$ is sufficient to
compute $F(20)$. With $m = 10$, our parallel function $K$ is expressed as follows:

$$
  \begin{align*}
    K(t) & = \begin{cases}
      F(m-1) & t = 0 \\
      F(m)   & t = 1 \\
      fib(t)\cdot F(m) + fib(t-1)\cdot F(m-1) & t \geq 2
    \end{cases} \\
    & \Rightarrow K(t) = \begin{cases}
      fib(9) & t = 0 \\
      fib(10)   & t = 1 \\
      fib(t)\cdot fib(10) + fib(t-1)\cdot fib(9) & t \geq 2
    \end{cases}
  \end{align*}
$$

Next, let us calculate the 11th element of the $K$ sequence, as shown in $(I)$: $K(11) = F(m + 11 - 1) = F(20) = fib(20)$

$$
  \begin{align*}
    K(11) &= fib(11) \cdot fib(10) + fib(10) \cdot fib(9) \\
          &= [fib(10) + fib(9)]\cdot fib(10) + fib(10)\cdot fib(9)
  \end{align*}
$$

Since $fib(10)$ and $fib(9)$ are known values in this example, we can compute the final value of $K(11)$.

$$
  \begin{align*}
    K(11) &= [fib(10) + fib(9)]\cdot fib(10) + fib(10)\cdot fib(9) \\
    &= (55+34) \cdot 55 + 55 \cdot 34 \\
    &= 6765 \\
    &= fib(20)
  \end{align*}
$$

This example shows how to use parallel sequences to discover values ahead from the current computed terms, 
without needing to traverse the intermediate terms.

## Computing a term of Fibonacci faster

In the section above, we demonstrated how to apply the some properties of the Fibonacci sequence to
compute a term $fib(2n)$ using $fib(n)$ and $fib(n-1)$, but we can apply this principle to compute 
a general $fib(n)$ faster. The first thing needed is a starting point for building our sequence, $n = 1$ 
is used because it is the smallest power of 2 that can be used in the solution described in the previous section;

A faster way to compute the n-th position in the Fibonacci sequence is:
```
procedure fib(n) -> (f, f0)
  if n = 1 then
    return 1, 0
  end if

  // f and f0 are the fib(n/2) and fib(n/2-1)
  f, f0 = fib(floor(n / 2))

  // calculate fib(n) and store it in v
  v  = (f + f0) * f + f * f0

  // calculate fib(n-1) and store it in v0
  v0 = f * f + f0 * f0

  // if n is odd one more step is needed
  if n % 2 = 1 then
    return v + v0, v0
  end if

  return v, v0
end procedure
```

## Computing the sequence
The objective of this algorithm is to compute the Fibonacci sequence from $0$ until a given $x$ value 
in parallel, we now have  all the tools to split the work into smaller units of computation. First, 
we divide the interval $x$ into $w$ parts. Next, we compute and store $fib({i_{k}}\cdot w)$ and $fib({i_{k}}\cdot w+1)$ 
for $i=0$ to $i=w-1$. Each work unit can fill its assigned portion of the sequence independently, without relying on
results from other work units. This algorithm enables efficient parallel computing.

```
// compute n terms of the fibonacci sequence starting from f and f0
procedure fill_sequence(n, f, f0)
  for i from 1 to n do
    f, f0 = f + f0, f
  end for
end procedure

// compute fibonacci sequence from 0 to n using a number of parallel work units
procedure parallel_fib_sequence(n, units)
  // calculate the number of terms assigned to each work unit
  interval := floor(n / units)

  // if the interval is zero, the sequence cannot be split among multiple work units.
  // In this case the entire sequence is computed within the current work unit
  if interval = 0 then
    fill_sequence(0, 1, n)
    return
  end if

  // iterate over each work unit and calculate its
  // starting Fibonacci value and interval
  for i from 0 to interval - 1 do
    // calculate the starting fibonacci values for the interval assigned to the work unit
    f, f0 := fib(i * interval + 1)

    if i = 0 then
      f = 1
      f0 = 0
    end if

    // launch parallel work unit with the designated interval
    compute fill_sequence(interval, f, f0)
  end for

  // if n is not evenly divisible by the number of work units,
  // compute and fill the remaining sequence terms
  if n % units != 0 then
    f, f0 := fib(interval * (units - 1))
    fill_sequence(interval, f, f0)
  end if
end procedure
```
